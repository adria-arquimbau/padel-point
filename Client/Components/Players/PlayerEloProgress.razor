@using EventsManager.Shared.Responses
@using Color = Blazorise.Color

@inject HttpClient Http
@inject IToastService ToastService

@if (_loading)
{
    <LoadingSpinner></LoadingSpinner>
}
else
{
    if (OtherPlayerEloHistory == null)
    {
        <div class="elo-chart">
            <LineChart @ref="@_lineChart" TItem="double" />
        </div>
    }
    if (OtherPlayerEloHistory != null)
    {
        <div class="elo-chart">
            <LineChart @ref="_lineChart" TItem="double" />
        </div>
    }
}

@code {
    private bool _loading = false;
    
    [Parameter]
    public List<EloHistoryResponse>? OtherPlayerEloHistory { get; set; }
    
    private List<EloHistoryResponse>? _eloHistory;
    
    LineChart<double> _lineChart = new();
    List<string> _myPlayerBackgroundColors = new() { ChartColor.FromRgba( 255, 99, 132, 0.2f ) };
    List<string> _myPlayerBorderColors = new() { ChartColor.FromRgba( 255, 99, 132, 1f ) };
    List<string> _otherPlayerBackgroundColors = new() { ChartColor.FromRgba(99, 255, 132, 0.2f) };
    List<string> _otherPlayerBorderColors = new() { ChartColor.FromRgba(99, 255, 132, 1f) };
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await Get();
        if (firstRender && _eloHistory != null)
        {
            await HandleRedraw();
            StateHasChanged();
        }
    }

    private async Task Get()
    {
        _loading = true;
        try
        {
            var response = await Http.GetAsync("elohistory");

            if (response.IsSuccessStatusCode)
            {
                _eloHistory = await response.Content.ReadFromJsonAsync<List<EloHistoryResponse>>();

    // Add StateHasChanged after data fetch
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                ToastService.ShowError(error);
            }
        }
        catch (Exception)
        {
            ToastService.ShowError("Something went wrong, please try again later.");
        }
        finally
        {
            _loading = false;
        }
    }
    
    private async Task HandleRedraw()
    {
        if (_eloHistory != null && OtherPlayerEloHistory == null)
        {
            await _lineChart.Clear();
            await _lineChart.AddLabelsDatasetsAndUpdate(_eloHistory.Select(e => e.ChangeDate.ToShortDateString()).ToList()
                ,GetLineChartMyPlayerDataset());
        }

        if (_eloHistory != null && OtherPlayerEloHistory != null)
        {
            await _lineChart.Clear();
            await _lineChart.AddLabelsDatasetsAndUpdate(
                new []
                {
                    _eloHistory.Select(e => e.ChangeDate.ToShortDateString()).ToList(), 
                    OtherPlayerEloHistory.Select(e => e.ChangeDate.ToShortDateString()).ToList()
                }, new []
                {
                    GetLineChartMyPlayerDataset(),
                    GetLineChartOtherPlayerDataset()
                });
        }
    }

    private LineChartDataset<double> GetLineChartMyPlayerDataset()
    {
        return new LineChartDataset<double>
        {
            Label = "Your elo history",
            Data = _eloHistory?.Select(e => (double)e.Elo).ToList(),
            BackgroundColor = _myPlayerBackgroundColors,
            BorderColor = _myPlayerBorderColors,
            Fill = true,
            PointRadius = 3,
            CubicInterpolationMode = "monotone",
        };
    }
    
    private LineChartDataset<double> GetLineChartOtherPlayerDataset()
    {
        return new LineChartDataset<double>
        {
            Label = "His elo history",
            Data = OtherPlayerEloHistory?.Select(e => (double)e.Elo).ToList(),
            BackgroundColor = _otherPlayerBackgroundColors,
            BorderColor = _otherPlayerBorderColors,
            Fill = true,
            PointRadius = 3,
            CubicInterpolationMode = "monotone",
        };
    }
}

<style>
    .elo-chart{
        margin: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
</style>
